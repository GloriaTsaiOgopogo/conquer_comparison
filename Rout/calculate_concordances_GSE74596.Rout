
R version 3.3.1 (2016-06-21) -- "Bug in Your Hair"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

During startup - Warning message:
Setting LC_CTYPE failed, using "C" 
> args <- (commandArgs(trailingOnly = TRUE))
> for (i in 1:length(args)) {
+   eval(parse(text = args[[i]]))
+ }
> 
> suppressPackageStartupMessages(library(iCOBRA))
> suppressPackageStartupMessages(library(dplyr))
> suppressPackageStartupMessages(library(tidyr))
> 
> print(dataset)  ## Data set
[1] "GSE74596"
> print(filt)  ## Filtering
[1] ""
> print(cobradir)  ## Directory where to look for cobra object (output from prepare_cobra_for_evaluation.R)
[1] "output/cobra_data"
> print(outdir) ## Directory where to save the calculated concordances
[1] "output/concordances"
> 
> if (filt == "") {
+   exts <- filt
+ } else {
+   exts <- paste0("_", filt)
+ }
> 
> ## Set maximal number of top-ranked genes to consider
> maxrank <- 1000
> 
> ## ----------------------------- Help functions ----------------------------- ##
> 
> ## For each k in 1:maxrank, count the number of genes occurring each number of 
> ## times. The output is a data frame with three columns: nbr_occ, nbr_genes, k. 
> ## For a given row, interpret as follows: among the top-k genes from each 
> ## method, nbr_genes occur exactly nbr_occ times. 
> calculate_nbr_occurrences <- function(mtx, maxrank) {
+   if (ncol(mtx) > 1) {
+     M <- matrix(0, max(mtx[1:maxrank, ]), maxrank)
+     for (i in 1:ncol(mtx)) {
+       M[cbind(mtx[1:maxrank, i], 1:maxrank)] <- M[cbind(mtx[1:maxrank, i], 1:maxrank)] + 1
+     }
+     M <- M[rowSums(M) != 0, ]
+     M <- t(apply(M, 1, cumsum))
+     M2 <- matrix(0, ncol(mtx), maxrank)
+     for (i in 1:nrow(M)) {
+       M2[cbind(M[i, ], 1:ncol(M))] <- M2[cbind(M[i, ], 1:ncol(M))] + 1
+     }
+     M2 <- M2 %>% reshape2::melt() %>%
+       dplyr::rename(k = Var2, nbr_genes = value, nbr_occ = Var1)
+     M2 %>% dplyr::arrange(k, nbr_occ) %>%
+       dplyr::mutate(nbr_cols = ncol(mtx))
+   } else {
+     NULL
+   }
+ }
> 
> ## Calculate partial (cumulative) AUCs. 
> ## Assumes that x variable = k, y variable = nbr_genes
> calc_auc <- function(x) {
+   x %>% dplyr::mutate(dx = c(0, diff(k)),
+                       dy = c(0, diff(nbr_genes)),
+                       ys = c(0, nbr_genes[-length(nbr_genes)])) %>%
+     dplyr::mutate(AUC = cumsum(dx * dy/2 + dx * ys)) %>%
+     dplyr::mutate(AUCs = AUC/(k^2/2))
+ }
> 
> get_method <- function(x) sapply(strsplit(x, "\\."), .subset, 1)
> get_nsamples <- function(x) sapply(strsplit(x, "\\."), .subset, 2)
> get_repl <- function(x) sapply(strsplit(x, "\\."), .subset, 3)
> 
> ## ---------------------------- Prepare data -------------------------------- ##
> 
> cobra <- readRDS(paste0(cobradir, "/", dataset, exts, "_cobra.rds"))
> ## Set p-values and adjusted p-values for untested genes and genes with NA
> ## values to 1, so that they will be ranked last
> pval(cobra)[is.na(pval(cobra))] <- 1
> padj(cobra)[is.na(padj(cobra))] <- 1
> ## Similarly, set score for untested genes and genes with NA values to a value 
> ## below the smallest observed score and change the sign so that the smallest
> ## (most negative) score corresponds to the most significant gene
> if (nrow(iCOBRA::score(cobra)) > 0) {
+   iCOBRA::score(cobra)[is.na(iCOBRA::score(cobra))] <- 
+     min(iCOBRA::score(cobra), na.rm = TRUE) - 1
+   iCOBRA::score(cobra) <- -iCOBRA::score(cobra)
+ }
> 
> summary_data <- list()
> 
> ## Define the set of values that will be used to rank the genes
> pconc <- pval(cobra)
> ## For methods not returning p-values, use scores or adjusted p-values
> addm <- setdiff(colnames(iCOBRA::score(cobra)), colnames(pconc))
> if (length(addm) > 0) {
+   pconc <- dplyr::full_join(data.frame(gene = rownames(pconc), pconc),
+                             data.frame(gene = rownames(iCOBRA::score(cobra)), 
+                                        iCOBRA::score(cobra)[, addm]))
+   rownames(pconc) <- pconc$gene
+   pconc$gene <- NULL
+ }
> addm <- setdiff(colnames(padj(cobra)), colnames(pconc))
> if (length(addm) > 0) {
+   pconc <- dplyr::full_join(data.frame(gene = rownames(pconc), pconc),
+                             data.frame(gene = rownames(padj(cobra)), 
+                                        padj(cobra)[, addm]))
+   rownames(pconc) <- pconc$gene
+   pconc$gene <- NULL
+ }
Joining, by = "gene"
> ## Find ordering of each column and convert to matrix
> for (i in colnames(pconc)) {
+   pconc[, i] <- order(pconc[, i])
+ }
> pconc <- as.matrix(pconc)
> 
> all_methods <- unique(get_method(colnames(pconc)))
> all_nsamples <- unique(get_nsamples(colnames(pconc)))
> all_repl <- unique(get_repl(colnames(pconc)))
> 
> ## ----------------------- Calculate concordances --------------------------- ##
> ## Calculate the number of shared occurrences among top-k genes across a number
> ## of different scenarios. Also calculate concordance values (number of genes
> ## shared by *all* columns for given k) and calculate partial AUC for the
> ## concordance curve (k vs concordance). The AUCs is a scaled AUC, obtained by
> ## dividing with the maximum area = k^2/2
> 
> ## Across all instances (all sample sizes, all replicates), for given method
> nbrshared <- do.call(rbind, lapply(all_methods, function(mth) {
+   tmp <- calculate_nbr_occurrences(mtx = pconc[, which(get_method(colnames(pconc)) == mth)], 
+                                    maxrank = maxrank)
+   tmp$method <- mth
+   tmp
+ })) %>% dplyr::mutate(dataset = dataset, filt = filt)
> concvals <- nbrshared %>% 
+   dplyr::filter(nbr_occ == nbr_cols) %>%
+   dplyr::group_by(method) %>%
+   calc_auc()
> summary_data$concordance_fullds_bymethod <- concvals
> summary_data$nbrshared_fullds_bymethod <- nbrshared
> 
> ## Across all instances with the same sample size, for given method
> nbrshared_ss <- do.call(rbind, lapply(all_methods, function(mth) {
+   do.call(rbind, lapply(all_nsamples, function(i) {
+     tmp <- calculate_nbr_occurrences(
+       mtx = pconc[, intersect(which(get_method(colnames(pconc)) == mth),
+                               which(get_nsamples(colnames(pconc)) == i)), 
+                   drop = FALSE],
+       maxrank = maxrank)
+     if (!is.null(tmp)) {
+       tmp$method <- mth
+       tmp$ncells <- i
+       tmp
+     } else {
+       NULL
+     }
+   }))
+ })) %>% dplyr::mutate(dataset = dataset, filt = filt)
> nbrshared_ss$ncells <- 
+   factor(nbrshared_ss$ncells,
+          levels = sort(unique(as.numeric(as.character(nbrshared_ss$ncells)))))
> concvals_ss <- nbrshared_ss %>% 
+   dplyr::filter(nbr_occ == nbr_cols) %>%
+   dplyr::group_by(method, ncells) %>%
+   calc_auc()
> summary_data$concordance_byncells_bymethod <- concvals_ss
> summary_data$nbrshared_byncells_bymethod <- nbrshared_ss
> 
> ## Between pairwise instances with the same sample size, for given method
> nbrshared_pairwise <- do.call(rbind, lapply(all_methods, function(mth) {
+   do.call(rbind, lapply(all_nsamples, function(i) {
+     tmp <- pconc[, intersect(which(get_method(colnames(pconc)) == mth),
+                              which(get_nsamples(colnames(pconc)) == i)), drop = FALSE]
+     if (ncol(tmp) > 1) {
+       nsr <- NULL
+       for (j1 in 1:(ncol(tmp) - 1)) {
+         for (j2 in (j1 + 1):(ncol(tmp))) {
+           cv <- calculate_nbr_occurrences(mtx = tmp[, c(j1, j2)], maxrank = maxrank)
+           cv$ncells <- i
+           cv$replicate1 <- get_repl(colnames(tmp)[j1])
+           cv$replicate2 <- get_repl(colnames(tmp)[j2])
+           nsr <- rbind(nsr, cv)
+         }
+       }
+       nsr$method <- mth
+       nsr
+     } else {
+       NULL
+     }
+   }))
+ })) %>% dplyr::mutate(dataset = dataset, filt = filt)
> concvals_pairwise <- nbrshared_pairwise %>% 
+   dplyr::filter(nbr_occ == nbr_cols) %>%
+   dplyr::group_by(method, ncells, replicate1, replicate2) %>%
+   calc_auc()
> summary_data$concordance_pairwise_bymethod <- concvals_pairwise
> summary_data$nbrshared_pairwise_bymethod <- nbrshared_pairwise
> 
> ## Between pairs of methods, for a given data set instance (fixed sample size, replicate)
> nbrshared_btwmth <- do.call(rbind, lapply(all_nsamples, function(ss) {
+   do.call(rbind, lapply(all_repl, function(i) {
+     tmp <- pconc[, intersect(which(get_repl(colnames(pconc)) == i),
+                              which(get_nsamples(colnames(pconc)) == ss)), drop = FALSE]
+     if (ncol(tmp) > 1) {
+       nsr <- NULL
+       for (j1 in 1:(ncol(tmp) - 1)) {
+         for (j2 in (j1 + 1):(ncol(tmp))) {
+           cv <- calculate_nbr_occurrences(mtx = tmp[, c(j1, j2)], maxrank = maxrank)
+           cv$method1 <- get_method(colnames(tmp)[j1])
+           cv$method2 <- get_method(colnames(tmp)[j2])
+           nsr <- rbind(nsr, cv)
+         }
+       }
+       nsr$ncells <- ss
+       nsr$repl <- i
+       nsr
+     } else {
+       NULL
+     }
+   }))
+ })) %>% dplyr::mutate(dataset = dataset, filt = filt)
> concvals_btwmth <- nbrshared_btwmth %>% 
+   dplyr::filter(nbr_occ == nbr_cols) %>%
+   dplyr::group_by(method1, method2, ncells, repl) %>%
+   calc_auc()
> summary_data$concordance_betweenmethods_pairwise <- concvals_btwmth
> summary_data$nbrshared_betweenmethods_pairwise <- nbrshared_btwmth
> 
> ## Across all methods, for a given data set instance (fixed sample size, replicate)
> nbrshared_allmth <- do.call(rbind, lapply(all_nsamples, function(ss) {
+   do.call(rbind, lapply(all_repl, function(i) {
+     tmp <- pconc[, intersect(which(get_repl(colnames(pconc)) == i),
+                              which(get_nsamples(colnames(pconc)) == ss)), drop = FALSE]
+     if (ncol(tmp) > 1) {
+       nsr <- calculate_nbr_occurrences(mtx = tmp, maxrank = maxrank)
+       nsr$ncells <- ss
+       nsr$repl <- i
+       nsr
+     } else {
+       NULL
+     }
+   }))
+ })) %>% dplyr::mutate(dataset = dataset, filt = filt)
> concvals_allmth <- nbrshared_allmth  %>%
+   dplyr::filter(nbr_occ == nbr_cols) %>%
+   dplyr::group_by(ncells, repl) %>%
+   calc_auc()
> summary_data$concordance_betweenmethods_all <- concvals_allmth
> summary_data$nbrshared_betweenmethods_all <- nbrshared_allmth
> 
> ## -------------------------- Save output ----------------------------------- ##
> saveRDS(summary_data, file = paste0(outdir, "/", dataset, exts, "_concordances.rds"))
> 
> sessionInfo()
R version 3.3.1 (2016-06-21)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 14.04.5 LTS

locale:
 [1] LC_CTYPE=C                 LC_NUMERIC=C              
 [3] LC_TIME=en_CA.UTF-8        LC_COLLATE=en_CA.UTF-8    
 [5] LC_MONETARY=en_CA.UTF-8    LC_MESSAGES=en_CA.UTF-8   
 [7] LC_PAPER=en_CA.UTF-8       LC_NAME=C                 
 [9] LC_ADDRESS=C               LC_TELEPHONE=C            
[11] LC_MEASUREMENT=en_CA.UTF-8 LC_IDENTIFICATION=C       

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
[1] tidyr_0.6.1  dplyr_0.5.0  iCOBRA_1.2.0

loaded via a namespace (and not attached):
 [1] Rcpp_0.12.9          magrittr_1.5         munsell_0.4.3       
 [4] colorspace_1.3-2     xtable_1.8-2         R6_2.2.0            
 [7] stringr_1.1.0        ROCR_1.0-7           plyr_1.8.4          
[10] caTools_1.17.1       tools_3.3.1          shinydashboard_0.5.3
[13] DT_0.2               grid_3.3.1           gtable_0.2.0        
[16] KernSmooth_2.23-15   DBI_0.5-1            gtools_3.5.0        
[19] htmltools_0.3.5      lazyeval_0.2.0       assertthat_0.1      
[22] digest_0.6.12        tibble_1.2           gridExtra_2.2.1     
[25] shiny_1.0.0          reshape2_1.4.2       ggplot2_2.2.1       
[28] bitops_1.0-6         htmlwidgets_0.8      mime_0.5            
[31] stringi_1.1.2        gdata_2.17.0         limma_3.30.13       
[34] UpSetR_1.3.2         shinyBS_0.61         gplots_3.0.1        
[37] scales_0.4.1         httpuv_1.3.3        
> 
> proc.time()
    user   system  elapsed 
5455.599  215.915 5684.221 
